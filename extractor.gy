#!usr/bin/env groovy

package tolkienizer

@Grab ('edu.stanford.nlp:stanford-corenlp:3.8.0')
@Grab ('org.slf4j:slf4j-log4j12:1.7.10')
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.Paths
import java.io.StringReader
import edu.stanford.nlp.ie.AbstractSequenceClassifier
import edu.stanford.nlp.ie.crf.*
import edu.stanford.nlp.io.IOUtils
import edu.stanford.nlp.ling.CoreLabel
import edu.stanford.nlp.ling.CoreAnnotations
import edu.stanford.nlp.util.*
import edu.stanford.nlp.pipeline.*
import edu.stanford.nlp.process.PTBTokenizer
import edu.stanford.nlp.ling.HasWord
import edu.stanford.nlp.process.CoreLabelTokenFactory
import java.io.FileInputStream



// This function reads all mails and loads them into an ArrayList for testing purposes
void loadMailsToArray(dataDir, mailList) throws IOException {
    dataDir.eachFile() { child ->
        if (child.isFile()) mailList.add(new String(Files.readAllBytes(Paths.get(child.getAbsolutePath())), StandardCharsets.UTF_8))
        else loadMailsToArray(child, mailList)
    }
}

// This function returns a tokenized string
def tokenizeMail(mail) {
    splittedMail = mail.split("\n")
    cat = ""
    for (sentence in splittedMail) {
        ptbt = new PTBTokenizer<CoreLabel>(new StringReader(sentence), new CoreLabelTokenFactory(), "")
        while (ptbt.hasNext()) {
            slabel = ptbt.next()
            cat = cat + label + " "
        }
        cat = cat.trim() + "\n"
    }
    return cat
}

// This function returns a list of recognized NE
def createNEList(abstractSequenceClassifier, mailList, genderMapping) {
    entityList = []
    for (mail in mailList) {
        offsetList = abstractSequenceClassifier.classifyToCharacterOffsets(mail)
         nameList = []
        for (item in offsetList) {
            triple = new Triple(String, String, String)
            name = mail.substring(item.second(), item.third()).trim()
            triple.setFirst(item.first)
            triple.setSecond(name)
            triple.setThird("---")
            // >>>>> GENDER MAPPING TEST
            fname = name.split(" ")[0]
            if (item.first.equals("PERSON")) {
                gender = genderMapping.get(fname)
                if (gender == null) gender = "UNDEFINED"
                triple.setSecond(gender[0].toLowerCase() + " " + name)
                triple.setThird(gender)
            }
            // >>>>>
            nameList.add(triple)
        }
        entityList.add(nameList)
    }
    return entityList
}

// This prints a mail (int) with tagged NE, from a list of mails, using a classifier to show NE tags
void printNEInMail(ImailNumber, listOfMails, abstractSequenceClassifier) {
    if (mailNumber < listOfMails.size()) println abstractSequenceClassifier.classifyWithInlineXML(listOfMails.get(mailNumber))
    else println "Invalid mail number"
}
    


// ITERATIVE PROGRAM

// LOADING MAILS TO MEMORY
genderMapFile = "./resources/stanford_corenlp/gender_map"
genderMap = new Properties()
genderMap.load(new FileInputStream(genderMapFile))
corpusPath = new File("./resources/data/")
mails = []
loadMailsToArray(corpusPath, mails)
println "$mails.size mails loaded correctly."

// TEST STANFORD CORENLP
serializedClassifier = "./resources/stanford_corenlp/english.nowiki.3class.caseless.distsim.crf.ser.gz"
classifier = CRFClassifier.getClassifier(serializedClassifier)
// List<List<Triple<String, String, String>>> NEList = createNEList(classifier, mails)
// println(NEList.size()+ " mails analysed correctly.")
// printNEInMail(856, mails, classifier)
ll = createNEList(classifier, mails, genderMap)
println(ll.get(10))
println "$ll.size mails tagged."

sudonizersMap =["LOCATION": new SimpleSudonizer(new File("./resources/places.txt")), "ORGANIZATION":  new OrgSudonizer(new File("./resources/voc.txt")), "PERSON": new PersonSudonizer(new File("./resources/names.txt"))]

def sudonize(type, toSudonize) {
	return sudonizersMap[type] == null ? null : sudonizersMap[type].sudonize(toSudonize)
}

org = [] as Set
person = [] as Set
loc = [] as Set
for (mail in ll) {
    for (tlist in mail) {
        for (t in tlist) {
            if (t.first().equals("PERSON")) {
                person << t.second()
                println sudonize(t.first(), "m " + t.second())
            }
            else if (t.first().equals("ORGANIZATION")) {
                org << t.second()
                println sudonize(t.first(), t.second())
            }
            else if (t.first().equals("LOCATION")) {
                loc << t.second()
                println sudonize(t.first(), t.second())
            }
        }
    }
}
println "${org.size()} ORGS"
println "${loc.size()} LOCS"
println "${person.size()} HUMANS"
