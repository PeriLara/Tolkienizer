#!usr/bin/env groovy

package tolkienizer

@Grab ('edu.stanford.nlp:stanford-corenlp:3.8.0')
@Grab ('org.slf4j:slf4j-log4j12:1.7.10')
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.Paths
import java.io.File
import java.io.StringReader
import java.util.List
import java.util.ArrayList
import edu.stanford.nlp.ie.AbstractSequenceClassifier
import edu.stanford.nlp.ie.crf.*
import edu.stanford.nlp.io.IOUtils
import edu.stanford.nlp.ling.CoreLabel
import edu.stanford.nlp.ling.CoreAnnotations
import edu.stanford.nlp.util.*
import edu.stanford.nlp.pipeline.*
import edu.stanford.nlp.process.PTBTokenizer
import edu.stanford.nlp.ling.HasWord
import edu.stanford.nlp.process.CoreLabelTokenFactory


// This function reads all mails and loads them into an ArrayList for testing purposes
void loadMailsToArray(dataDir, mailList) throws IOException {
    dataDir.eachFile() { child ->
        if (child.isFile()) mailList.add(new String(Files.readAllBytes(Paths.get(child.getAbsolutePath())), StandardCharsets.UTF_8))
        else loadMailsToArray(child, mailList)
    }
}

// This function returns a tokenized string
def tokenizeMail(mail) {
    splittedMail = mail.split("\n")
    cat = ""
    for (sentence in splittedMail) {
        ptbt = new PTBTokenizer<CoreLabel>(new StringReader(sentence), new CoreLabelTokenFactory(), "")
        while (ptbt.hasNext()) {
            slabel = ptbt.next()
            cat = cat + label + " "
        }
        cat = cat.trim() + "\n"
    }
    return cat
}

// This function returns a list of recognized NE
def createNEList(abstractSequenceClassifier, mailList) {
    entityList = []
    for (mail in mailList) {
        offsetList = abstractSequenceClassifier.classifyToCharacterOffsets(mail)
         nameList = []
        for (item in offsetList) {
            triple = new Triple(String, String, String)
            triple.setFirst(item.first)
            triple.setSecond(mail.substring(item.second(), item.third()))
            triple.setThird("---")
            nameList.add(triple)
        }
        entityList.add(nameList)
    }
    return entityList
}

// This prints a mail (int) with tagged NE, from a list of mails, using a classifier to show NE tags
void printNEInMail(ImailNumber, listOfMails, abstractSequenceClassifier) {
    if (mailNumber < listOfMails.size()) println abstractSequenceClassifier.classifyWithInlineXML(listOfMails.get(mailNumber))
    else println "Invalid mail number"
}
    


// ITERATIVE PROGRAM

// LOADING MAILS TO MEMORY
corpusPath = new File("./resources/data/")
mails = []
loadMailsToArray(corpusPath, mails)
println "$mails.size mails loaded correctly."

// TEST STANFORD CORENLP
serializedClassifier = "./resources/stanford_corenlp/english.nowiki.3class.caseless.distsim.crf.ser.gz"
classifier = CRFClassifier.getClassifier(serializedClassifier)
// List<List<Triple<String, String, String>>> NEList = createNEList(classifier, mails)
// println(NEList.size()+ " mails analysed correctly.")
// printNEInMail(856, mails, classifier)
ll = createNEList(classifier, mails)
println "$ll.size mails tagged."

org = [] as Set
person = [] as Set
loc = [] as Set
for (mail in ll) {
    for (tlist in mail) {
        for (t in tlist) {
            if (t.first().equals("PERSON")) {
                person << t.second()
            }
            else if (t.first().equals("ORGANIZATION")) {
                org << t.second()
            }
            else if (t.first().equals("LOCATION")) {
                loc << t.second()
            }
        }
    }
}
println "$org.size() ORGS"
println "$loc.size() LOCS"
println "$person.size() HUMANS"
